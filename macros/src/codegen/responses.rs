use std::collections::BTreeSet;

use convert_case::{Case, Casing};
use proc_macro2::TokenStream;
use quote::{quote, quote_spanned};
use syn::spanned::Spanned;
use syn::{Ident, Type, parse_quote_spanned};

use crate::args::AutorouteInput;
use crate::args::responses::{AutorouteResponse, AutorouteResponseSerializer};
use crate::syn_bail;

pub(crate) fn declare_responses_enum(input: &AutorouteInput) -> syn::Result<proc_macro2::TokenStream> {
    let fn_name = input.fn_ident();
    let enum_name = responses_enum_ident(input);

    let mut variant_declarations = Vec::new();
    let mut variant_into_response_impls = Vec::new();
    let mut variant_response_trait_impls = Vec::new();
    let mut already_used_codes = BTreeSet::new();
    for resp in &*input.meta.responses {
        // check unicity of status code for a route
        let status_code = resp.status_code;
        if !already_used_codes.insert(status_code) {
            syn_bail!(
                status_code.span(),
                "status code already defined in a previous response for this route"
            );
        }

        let variant_name = response_variant_ident(resp);
        let body_type = resp.body.clone();
        let parts_types = resp.parts.clone();

        // declaration of the variant for this response
        variant_declarations.push(quote_spanned! {resp.span=>
            #variant_name( #(#parts_types,)* #body_type )
        });

        // implementation of axum IntoResponse for this response
        variant_into_response_impls.push(response_variant_into_response_impl(input, resp));

        // implementation of the custom status trait (e.g. `IntoNotFound`) for this response
        variant_response_trait_impls.push(response_variant_trait_impl(&enum_name, resp));
    }

    let msg = format!("Enum containing the different response types for the handler {fn_name}  ");
    let vis = input.itemfn.vis.clone();
    Ok(quote_spanned! {input.meta.responses.span()=>
        #[doc=#msg]
        #[doc="**Automatically generated by the `axum_autoroute::autoroute` macro**"]
        #[allow(clippy::large_enum_variant)]
        #vis enum #enum_name {
            #(#variant_declarations),*
        }

        impl axum::response::IntoResponse for #enum_name {
            fn into_response(self) -> axum::response::Response {
                match self {
                    #(#variant_into_response_impls),*
                }
            }
        }

        #(#variant_response_trait_impls)*
    })
}

/// Name of the responses enum as String
pub(crate) fn responses_enum_name(input: &AutorouteInput) -> String {
    let fn_ident = input.fn_ident();
    format!("{}Responses", fn_ident.to_string().to_case(Case::Pascal))
}

/// Name of the responses enum as Ident
pub(crate) fn responses_enum_ident(input: &AutorouteInput) -> Ident {
    let fn_ident = input.fn_ident();
    Ident::new(&responses_enum_name(input), fn_ident.span())
}

/// Name of the variant for a response (e.g. `NotFound`)
fn response_variant_ident(resp: &AutorouteResponse) -> Ident {
    let status_name = resp.status_code.to_string().to_case(Case::Pascal);
    Ident::new(&status_name, resp.span)
}

/// Name of the variables set when destructuring the variant (first the body and the parts afterward)
pub(crate) fn response_variant_variables(resp: &AutorouteResponse) -> (Ident, Vec<Ident>) {
    let body_var = Ident::new("body", resp.body.span());
    let parts_vars: Vec<Ident> = resp
        .parts
        .iter()
        .enumerate()
        .map(|(i, part_type)| Ident::new(&format!("part{i}"), part_type.span()))
        .collect();
    (body_var, parts_vars)
}

/// Name of the associated status code reponse trait (e.g. `IntoNotFound`)
fn response_into_status_trait_name(resp: &AutorouteResponse) -> Ident {
    Ident::new(
        &format!("Into{}", resp.status_code.to_string().to_case(Case::Pascal)),
        resp.status_code.span(),
    )
}

/// Name of the associated status code reponse trait function (e.g. `into_not_found`)
fn response_into_status_trait_fn_name(resp: &AutorouteResponse) -> Ident {
    Ident::new(
        &format!("into_{}", resp.status_code.to_string().to_case(Case::Snake)),
        resp.status_code.span(),
    )
}

fn response_variant_into_response_impl(
    #[cfg_attr(not(feature = "tracing"), expect(unused))] input: &AutorouteInput,
    resp: &AutorouteResponse,
) -> TokenStream {
    let variant_name = response_variant_ident(resp);
    let status_code_ident = Ident::new(&resp.status_code.to_string(), resp.status_code.span());
    let (body_var, parts_vars) = response_variant_variables(resp);

    // use the provided serializer or Json by default
    let serializer_expr = match &resp.serializer {
        AutorouteResponseSerializer::Default => {
            if cfg!(feature = "default_serializer_json") {
                quote_spanned! {body_var.span()=> { axum::Json(#body_var)} }
            } else {
                quote! {#body_var}
            }
        }
        AutorouteResponseSerializer::None => quote! {#body_var},
        AutorouteResponseSerializer::Path { path } => {
            quote_spanned! {path.span()=> #path(#body_var)}
        }
    };

    #[cfg(feature = "tracing")]
    let tracing_stmt = crate::codegen::tracing::output_tracing(input, &body_var, resp);
    #[cfg(not(feature = "tracing"))]
    let tracing_stmt = quote! {};

    quote_spanned! {resp.span=>
        Self::#variant_name(#(#parts_vars,)* #body_var) => {
            #tracing_stmt
            (
                axum::http::status::StatusCode::#status_code_ident,
                #(#parts_vars,)*
                #serializer_expr,
            ).into_response()
        }
    }
}

fn response_variant_trait_impl(enum_name: &Ident, resp: &AutorouteResponse) -> TokenStream {
    let variant_name = response_variant_ident(resp);
    let trait_name = response_into_status_trait_name(resp);
    let trait_fn = response_into_status_trait_fn_name(resp);

    let body_type = resp.body.clone();
    let parts_types = resp.parts.clone();

    // the type for which to implement the trait (either a simple type or a tuple with parts and body content)
    let impl_for = if parts_types.is_empty() {
        body_type
    } else {
        Type::Tuple(parse_quote_spanned! {resp.span=> (#(#parts_types),* , #body_type)})
    };

    // the implementation of the into_xxx function of the trait
    let variant_impl = if parts_types.is_empty() {
        quote_spanned! {resp.span=>
            #enum_name::#variant_name(self)
        }
    } else {
        // tuple starting with the parts types and ending with the body type
        let (body_var, parts_vars) = response_variant_variables(resp);
        quote_spanned! {resp.span=>
            let (#(#parts_vars),* , #body_var) = self;
            #enum_name::#variant_name(#(#parts_vars),* , #body_var)
        }
    };

    quote_spanned! {resp.span=>
        impl axum_autoroute::status_trait::#trait_name<#enum_name> for #impl_for {
            fn #trait_fn(self) -> #enum_name {
                #variant_impl
            }
        }
    }
}
